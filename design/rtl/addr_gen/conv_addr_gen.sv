`timescale 1ns / 1ps
///////////////////////////////////////////////////////////////////////////////////////////////
// Institution:     RWTH Aachen - DSP chair
// Author:          Martin Lastovka : martin.lastovka@dsp.rwth-aachen.de
// Module Name:     conv_addr_gen
// Project Name:    Efficient FPGA CNN implementation
// Description:     Address generation unit for convolution. Based on the row and index columns
//                  indices (of the equivalent matrix) generated by the primary Adress generation unit, 
//                  we compute the indices x,y,z indices of the feature tensor (1. stage), then figure
//                  out if they are part of the padding boundary and offset them by the padding value
//                  (2. stage) and then we compute the final vector address (3. stage)
// Synthesizable:   Yes
///////////////////////////////////////////////////////////////////////////////////////////////

import arith_pckg::*;
import proc_pipe_pckg::*;
import mem_pckg::*;

module conv_addr_gen
(
    //clk & reset & enable
    input  logic clk,
    input  logic rst_n,
    input  logic clk_en,
    //control
    input  tens_trans_spec_t  conv_tens_trans_spec,
    input  mem_cmd_rd_t       conv_addr_gen_rd_mmem,
    //data & address 
    input  logic [C_TENS_INDEX_WDT-1:0] conv_addr_gen_row_i,
    input  logic [C_TENS_INDEX_WDT-1:0] conv_addr_gen_col_i,
    input  logic                        conv_addr_gen_val,
    output mem_cmd_rd_t                 conv_addr_gen_rd_mmem_q
);

//input delay chain

logic [$bits(conv_addr_gen_row_i) + $bits(conv_addr_gen_col_i) + $bits(conv_addr_gen_val)-1:0] conv_addr_gen_in_del;
logic [C_TENS_INDEX_WDT-1:0] conv_addr_gen_row_i_del;
logic [C_TENS_INDEX_WDT-1:0] conv_addr_gen_col_i_del;
logic                        conv_addr_gen_val_del;
mem_cmd_rd_t                 conv_addr_gen_rd_mmem_i;
logic                        conv_addr_gen_rd_mmem_val;

del_chain
#(
    .IN_WORD_WDT($bits(conv_addr_gen_in_del)),
    .DEL_CYC_LEN(C_CONV_ADDR_GEN_IN_DEL_CYC_LEN)
)
conv_addr_gen_fetch_del_chain
(
    .clk(clk),
    .rst_n(rst_n),
    .clk_en(clk_en),
    .in_word({conv_addr_gen_row_i, conv_addr_gen_col_i, conv_addr_gen_val}),
    .in_word_val(),
    .in_word_del(conv_addr_gen_in_del),
    .in_word_val_del()
);

always_comb begin //unpack
    conv_addr_gen_val_del       = conv_addr_gen_in_del[0 +: $bits(conv_addr_gen_val_del)];
    conv_addr_gen_col_i_del     = conv_addr_gen_in_del[$bits(conv_addr_gen_val_del) +: $bits(conv_addr_gen_col_i_del)];
    conv_addr_gen_row_i_del     = conv_addr_gen_in_del[$bits(conv_addr_gen_val_del) + $bits(conv_addr_gen_col_i_del) +: $bits(conv_addr_gen_row_i_del)];
end

del_chain //delay the read command data while the address is being computed
#(
    .IN_WORD_WDT($bits(conv_addr_gen_rd_mmem_q)),
    .DEL_CYC_LEN(C_CONV_ADDR_GEN_TOT_STAGE_CYC_LEN)
)
conv_addr_gen_rd_mmem_del_chain
(
    .clk(clk),
    .rst_n(rst_n),
    .clk_en(clk_en),
    .in_word(conv_addr_gen_rd_mmem),
    .in_word_val(conv_addr_gen_val),
    .in_word_del(conv_addr_gen_rd_mmem_i),
    .in_word_val_del(conv_addr_gen_rd_mmem_val)
);


//-------------------------------------------------------------
//Stage 1------------------------------------------------------
//-------------------------------------------------------------

//based on the row index (i) and column index (j) compute the following:
//
// x = (j * stride[1] % (TENS_OUT[1] * stride[1])) + ((i // v_f) % KERN[1])
// y = (j * stride[1] // (TENS_OUT[1] * stride[1])) * stride[0] + ((i // v_f) // KERN[1])
// z = i % v_f
//
//Where i = row index, j = column index, v_f = TENS_IN[2] // vector size, 
//TENS_IN, TENS_OUT, KERN are the input, output feature tensors and kernel tensor dims respectively,
//and stride is the kernel stride

logic [C_TENS_INDEX_WDT-1:0] div_row_v_f_quot;
logic [C_TENS_INDEX_WDT-1:0] div_row_v_f_rem;
logic div_row_v_f_val;
logic [C_TENS_INDEX_WDT-1:0] div_kern_row_quot;
logic [C_TENS_INDEX_WDT-1:0] div_kern_row_rem;
logic div_kern_row_val;
logic [2*C_TENS_INDEX_WDT-1:0] mult_col_stride;
logic mult_col_stride_val;
logic [2*C_TENS_INDEX_WDT-1:0] mult_width_stride;
logic mult_width_stride_val;
logic [C_TENS_INDEX_WDT-1:0] div_col_stride_quot;
logic [C_TENS_INDEX_WDT-1:0] div_col_stride_rem;
logic div_col_stride_val;
logic div_col_stride_val_del;
logic [C_TENS_INDEX_WDT-1:0] div_col_stride_rem_del;
logic [2*C_TENS_INDEX_WDT-1:0] mult_div_col_stride;
logic mult_div_col_stride_val;
logic [2*C_TENS_INDEX_WDT-1:0] mult_div_col_stride_del;
logic mult_div_col_stride_val_del;
logic [C_TENS_INDEX_WDT-1:0] conv_addr_gen_z_i;
logic conv_addr_gen_z_i_val;
logic [C_TENS_INDEX_WDT-1:0] conv_addr_gen_x_i;
logic conv_addr_gen_x_i_val;
logic [C_TENS_INDEX_WDT-1:0] conv_addr_gen_y_i;
logic conv_addr_gen_y_i_val;

int_div
#(
    .D_END_WORD_WDT(C_D_END_TENS_INDEX_WDT),
    .D_QUOT_WORD_WDT(C_TENS_INDEX_WDT),
    .D_QUOT_BITS_PER_CYCLE(C_D_QUOT_BITS_PER_CYCLE)
)
int_div_row_vect_fact //compute: i % v_f, i // v_f
(
    .clk     (clk),
    .rst_n   (rst_n),
    .clk_en  (clk_en),
    .op_d_end({{(C_D_END_TENS_INDEX_WDT - $bits(conv_addr_gen_row_i_del)){1'b0}}, conv_addr_gen_row_i_del}),
    .op_d_or (conv_tens_trans_spec.tens_trans_conv_dims.tens_src_b_dims.tens_2_dim),
    .op_val  (conv_addr_gen_val_del),
    .res_quot(div_row_v_f_quot),
    .res_rem (div_row_v_f_rem), //z coordinate
    .res_val (div_row_v_f_val)
);

del_chain //delay the z index to match the 1.stage latency
#(
    .IN_WORD_WDT(C_TENS_INDEX_WDT),
    .DEL_CYC_LEN(C_CONV_ADDR_GEN_Z_I_CYC_LEN)
)
conv_addr_gen_z_i_del_chain
(
    .clk(clk),
    .rst_n(rst_n),
    .clk_en(clk_en),
    .in_word(div_row_v_f_rem),
    .in_word_val(div_row_v_f_val),
    .in_word_del(conv_addr_gen_z_i),
    .in_word_val_del(conv_addr_gen_z_i_val)
);

int_div
#(
    .D_END_WORD_WDT(C_D_END_TENS_INDEX_WDT),
    .D_QUOT_WORD_WDT(C_TENS_INDEX_WDT),
    .D_QUOT_BITS_PER_CYCLE(C_D_QUOT_BITS_PER_CYCLE)
)
int_div_kern_row //compute: ((i // v_f) // KERN[1]), ((i // v_f) % KERN[1])
(
    .clk     (clk),
    .rst_n   (rst_n),
    .clk_en  (clk_en),
    .op_d_end({{(C_D_END_TENS_INDEX_WDT - $bits(div_row_v_f_quot)){1'b0}}, div_row_v_f_quot}),
    .op_d_or (conv_tens_trans_spec.tens_trans_conv_dims.tens_src_a_dims.tens_1_dim),
    .op_val  (div_row_v_f_val),
    .res_quot(div_kern_row_quot),
    .res_rem (div_kern_row_rem), 
    .res_val (div_kern_row_val)
);

mult_cell
#(
    .MULT_ARITH_CFG(C_ADDR_MULT_ARITH_CFG),
    .MULT_IN_CYC_LEN(C_MULT_ADDR_IN_CYC_LEN),
    .MULT_OUT_CYC_LEN(C_MULT_ADDR_OUT_CYC_LEN)
)
mult_col_stride_unit //compute: j * stride[1]
( 
  .clk(clk),
  .rst_n(rst_n),
  .clk_en(clk_en),
  .mult_op_a(conv_addr_gen_col_i_del), 
  .mult_op_b({{(C_ADDR_MULT_ARITH_CFG.word_wdt - $bits(conv_tens_trans_spec.tens_trans_cfg.conv_cfg.conv_stride_1)){1'b0}}, conv_tens_trans_spec.tens_trans_cfg.conv_cfg.conv_stride_1}), //TODO: now only symmetric stride, generalize this later
  .mult_op_val(conv_addr_gen_val_del),
  .mult_res(mult_col_stride),
  .mult_res_val(mult_col_stride_val)
);

mult_cell
#(
    .MULT_ARITH_CFG(C_ADDR_MULT_ARITH_CFG),
    .MULT_IN_CYC_LEN(C_MULT_ADDR_IN_CYC_LEN),
    .MULT_OUT_CYC_LEN(C_MULT_ADDR_OUT_CYC_LEN)
)
mult_width_stride_unit //compute: TENS_OUT[1] * stride[1]
( 
  .clk(clk),
  .rst_n(rst_n),
  .clk_en(clk_en),
  .mult_op_a(conv_tens_trans_spec.tens_trans_conv_dims.tens_res_dims.tens_1_dim), 
  .mult_op_b({{(C_ADDR_MULT_ARITH_CFG.word_wdt - $bits(conv_tens_trans_spec.tens_trans_cfg.conv_cfg.conv_stride_1)){1'b0}}, conv_tens_trans_spec.tens_trans_cfg.conv_cfg.conv_stride_1}), //TODO: now only symmetric stride, generalize this later
  .mult_op_val(conv_addr_gen_val_del),
  .mult_res(mult_width_stride),
  .mult_res_val(mult_width_stride_val)
);

int_div
#(
    .D_END_WORD_WDT(C_D_END_TENS_INDEX_WDT),
    .D_QUOT_WORD_WDT(C_TENS_INDEX_WDT),
    .D_QUOT_BITS_PER_CYCLE(C_D_QUOT_BITS_PER_CYCLE)
)
int_div_col_stride //compute: (j * stride[1] % (TENS_OUT[1] * stride[1])), (j * stride[1] // (TENS_OUT[1] * stride[1]))
(
    .clk     (clk),
    .rst_n   (rst_n),
    .clk_en  (clk_en),
    .op_d_end(mult_col_stride[C_D_END_TENS_INDEX_WDT-1:0]),
    .op_d_or (mult_width_stride),
    .op_val  (mult_width_stride_val & mult_col_stride_val),
    .res_quot(div_col_stride_quot),
    .res_rem (div_col_stride_rem), 
    .res_val (div_col_stride_val)
);

del_chain //delay the (j * stride[1] // (TENS_OUT[1] * stride[1])) to match latency of ((i // v_f) % KERN[1])
#(
    .IN_WORD_WDT(C_TENS_INDEX_WDT),
    .DEL_CYC_LEN(C_DIV_COL_STRIDE_REM_DEL_CYC_LEN)
)
conv_addr_gen_div_col_stride_del_chain
(
    .clk(clk),
    .rst_n(rst_n),
    .clk_en(clk_en),
    .in_word(div_col_stride_rem),
    .in_word_val(div_col_stride_val),
    .in_word_del(div_col_stride_rem_del),
    .in_word_val_del(div_col_stride_val_del)
);

add_cell //compute (j * stride[1] // (TENS_OUT[1] * stride[1])) + ((i // v_f) % KERN[1])
#(
    .ADD_ARITH_CFG(C_ADDR_ADD_ARITH_CFG),
    .ADD_IN_CYC_LEN(C_ADD_ADDR_IN_CYC_LEN),
    .ADD_OUT_CYC_LEN(C_ADD_ADDR_OUT_CYC_LEN)
)
conv_addr_gen_x_i_add
( 
  .clk(clk),
  .rst_n(rst_n),
  .clk_en(clk_en),
  .add_op_a(div_col_stride_rem_del), 
  .add_op_b(div_kern_row_rem),
  .add_op_val(div_kern_row_val & div_col_stride_val_del),
  .add_res(conv_addr_gen_x_i),
  .add_res_val(conv_addr_gen_x_i_val)
);

mult_cell
#(
    .MULT_ARITH_CFG(C_ADDR_MULT_ARITH_CFG),
    .MULT_IN_CYC_LEN(C_MULT_ADDR_IN_CYC_LEN),
    .MULT_OUT_CYC_LEN(C_MULT_ADDR_OUT_CYC_LEN)
)
mult_div_col_stride_unit //compute: (j * stride[1] // (TENS_OUT[1] * stride[1])) * stride[0]
( 
  .clk(clk),
  .rst_n(rst_n),
  .clk_en(clk_en),
  .mult_op_a(div_col_stride_quot), 
  .mult_op_b({{(C_ADDR_MULT_ARITH_CFG.word_wdt - $bits(conv_tens_trans_spec.tens_trans_cfg.conv_cfg.conv_stride_0)){1'b0}}, conv_tens_trans_spec.tens_trans_cfg.conv_cfg.conv_stride_0}), //TODO: now only symmetric stride, generalize this later
  .mult_op_val(div_col_stride_val),
  .mult_res(mult_div_col_stride),
  .mult_res_val(mult_div_col_stride_val)
);

del_chain //delay the (j * stride[1] // (TENS_OUT[1] * stride[1])) * stride[0] to match latency of ((i // v_f) // KERN[1])
#(
    .IN_WORD_WDT(2*C_TENS_INDEX_WDT),
    .DEL_CYC_LEN(C_MULT_DIV_COL_STRIDE_DEL_CYC_LEN)
)
mult_div_col_stride_del_chain
(
    .clk(clk),
    .rst_n(rst_n),
    .clk_en(clk_en),
    .in_word(mult_div_col_stride),
    .in_word_val(mult_div_col_stride_val),
    .in_word_del(mult_div_col_stride_del),
    .in_word_val_del(mult_div_col_stride_val_del)
);

add_cell //compute (j * stride[1] // (TENS_OUT[1] * stride[1])) * stride[0] + ((i // v_f) // KERN[1])
#(
    .ADD_ARITH_CFG(C_ADDR_ADD_ARITH_CFG),
    .ADD_IN_CYC_LEN(C_ADD_ADDR_IN_CYC_LEN),
    .ADD_OUT_CYC_LEN(C_ADD_ADDR_OUT_CYC_LEN)
)
conv_addr_gen_y_i_add
( 
  .clk(clk),
  .rst_n(rst_n),
  .clk_en(clk_en),
  .add_op_a(mult_div_col_stride_del), 
  .add_op_b(div_kern_row_quot),
  .add_op_val(div_kern_row_val & mult_div_col_stride_val_del),
  .add_res(conv_addr_gen_y_i),
  .add_res_val(conv_addr_gen_y_i_val)
);

//-------------------------------------------------------------
//Stage 2------------------------------------------------------
//-------------------------------------------------------------

//we decide whether the x,y,z indices are inside the zero padding area, then no address computation is needed
//padding if x - padd[1] < 0 or x - padd[1] >= TENS_IN[1] or y - padd[0] < 0 or y - padd[0] >= TENS_IN[0]
//also offset x,y,z so that it corresponds to the original (unpadded) feature tensor, i.e. x = x - padd[1], y = y - padd[0]

logic conv_addr_gen_i_val;
logic [C_TENS_INDEX_WDT-1:0] conv_addr_padd_0_neg;
logic [C_TENS_INDEX_WDT-1:0] conv_addr_padd_1_neg;
logic conv_addr_padd;
logic [C_TENS_INDEX_WDT-1:0] conv_addr_gen_z_i_off;
logic [C_TENS_INDEX_WDT-1:0] conv_addr_gen_x_i_off;
logic [C_TENS_INDEX_WDT-1:0] conv_addr_gen_y_i_off;
logic conv_addr_gen_z_i_off_val;
logic conv_addr_gen_x_i_off_val;
logic conv_addr_gen_y_i_off_val;
logic conv_addr_gen_i_off_val;
logic conv_addr_gen_i_off_val_i;
logic conv_addr_padd_del;
logic conv_addr_padd_val_del;

//prepare the negative padding constants
always_ff @(posedge clk) begin : conv_addr_gen_padd
    if(!rst_n) begin
        conv_addr_padd_0_neg      <= '0;
        conv_addr_padd_1_neg      <= '0;
        conv_addr_gen_i_off_val_i <= 1'b0;
    end else begin
        if(clk_en) begin
            conv_addr_padd_0_neg      <= -conv_tens_trans_spec.tens_trans_cfg.conv_cfg.conv_padding_0; //TODO: now only symmetric padding is supported
            conv_addr_padd_1_neg      <= -conv_tens_trans_spec.tens_trans_cfg.conv_cfg.conv_padding_1;
            conv_addr_padd       <= conv_addr_gen_i_off_val & ($signed(conv_addr_gen_x_i_off) < 0 | $signed(conv_addr_gen_x_i_off) >= conv_tens_trans_spec.tens_trans_conv_dims.tens_src_b_dims.tens_1_dim |
                                        $signed(conv_addr_gen_y_i_off) < 0 | $signed(conv_addr_gen_y_i_off) >= conv_tens_trans_spec.tens_trans_conv_dims.tens_src_b_dims.tens_0_dim);
            conv_addr_gen_i_off_val_i <= conv_addr_gen_i_off_val;
        end
    end
end

del_chain //delay the padding flag
#(
    .IN_WORD_WDT(1),
    .DEL_CYC_LEN(C_CONV_ADDR_GEN_PADD_DEL_CYC_LEN)
)
conv_addr_padd_del_chain
(
    .clk(clk),
    .rst_n(rst_n),
    .clk_en(clk_en),
    .in_word(conv_addr_padd),
    .in_word_val(conv_addr_gen_i_off_val_i),
    .in_word_del(conv_addr_padd_del),
    .in_word_val_del(conv_addr_padd_val_del)
);

assign conv_addr_gen_i_val = conv_addr_gen_z_i_val & conv_addr_gen_x_i_val & conv_addr_gen_y_i_val;
assign conv_addr_gen_i_off_val = conv_addr_gen_z_i_off_val & conv_addr_gen_x_i_off_val & conv_addr_gen_y_i_off_val;

add_cell //compute: x - padd[1]
#(
    .ADD_ARITH_CFG(C_ADDR_ADD_ARITH_CFG),
    .ADD_IN_CYC_LEN(C_ADD_ADDR_IN_CYC_LEN),
    .ADD_OUT_CYC_LEN(C_ADD_ADDR_OUT_CYC_LEN)
)
conv_addr_gen_x_i_off_add
( 
  .clk(clk),
  .rst_n(rst_n),
  .clk_en(clk_en),
  .add_op_a(conv_addr_gen_x_i), 
  .add_op_b(conv_addr_padd_1_neg),
  .add_op_val(conv_addr_gen_i_val),
  .add_res(conv_addr_gen_x_i_off),
  .add_res_val(conv_addr_gen_x_i_off_val)
);

add_cell //compute: y - padd[0]
#(
    .ADD_ARITH_CFG(C_ADDR_ADD_ARITH_CFG),
    .ADD_IN_CYC_LEN(C_ADD_ADDR_IN_CYC_LEN),
    .ADD_OUT_CYC_LEN(C_ADD_ADDR_OUT_CYC_LEN)
)
conv_addr_gen_y_i_off_add
( 
  .clk(clk),
  .rst_n(rst_n),
  .clk_en(clk_en),
  .add_op_a(conv_addr_gen_y_i), 
  .add_op_b(conv_addr_padd_0_neg),
  .add_op_val(conv_addr_gen_i_val),
  .add_res(conv_addr_gen_y_i_off),
  .add_res_val(conv_addr_gen_y_i_off_val)
);

del_chain //delay z index 
#(
    .IN_WORD_WDT(C_TENS_INDEX_WDT),
    .DEL_CYC_LEN(C_ADD_ADDR_CYC_LEN)
)
conv_addr_gen_z_i_off_add_del_chain
(
    .clk(clk),
    .rst_n(rst_n),
    .clk_en(clk_en),
    .in_word(conv_addr_gen_z_i),
    .in_word_val(conv_addr_gen_i_val),
    .in_word_del(conv_addr_gen_z_i_off),
    .in_word_val_del(conv_addr_gen_z_i_off_val)
);

//-------------------------------------------------------------
//Stage 3------------------------------------------------------
//-------------------------------------------------------------

//based on the x,y,z indices, compute the vector address as: addr = offset + x + TENS_IN[1] * (y + TENS_IN[0] * z)
//first compute offset + x and TENS_IN[0] * z in paralell
//then y + TENS_IN[0] * z
//then TENS_IN[1] * (y + TENS_IN[0] * z)
//finally offset + x + TENS_IN[1] * (y + TENS_IN[0] * z)

logic conv_addr_gen_x_offset_val;
logic [C_MMEM_ADDR_WDT-1:0] conv_addr_gen_x_offset;
logic conv_addr_gen_x_offset_val_del;
logic [C_MMEM_ADDR_WDT-1:0] conv_addr_gen_x_offset_del;
logic conv_addr_gen_z_height_val;
logic [C_TENS_INDEX_WDT-1:0] conv_addr_gen_z_height;
logic [C_TENS_INDEX_WDT-1:0] conv_addr_gen_y_i_off_del;
logic conv_addr_gen_i_off_val_del;
logic [C_TENS_INDEX_WDT-1:0] conv_addr_gen_yz;
logic conv_addr_gen_yz_val;
logic [C_MMEM_ADDR_WDT-1:0] conv_addr_gen_yz_width;
logic conv_addr_gen_yz_width_val;
logic [C_MMEM_ADDR_WDT-1:0] conv_addr_gen_fin;
logic conv_addr_gen_fin_val;

add_cell 
#(
    .ADD_ARITH_CFG(C_ADDR_ADD_ARITH_CFG),
    .ADD_IN_CYC_LEN(C_ADD_ADDR_IN_CYC_LEN),
    .ADD_OUT_CYC_LEN(C_ADD_ADDR_OUT_CYC_LEN)
)
add_conv_addr_gen_x_offset //compute: offset + x
( 
  .clk(clk),
  .rst_n(rst_n),
  .clk_en(clk_en),
  .add_op_a(conv_addr_gen_x_i_off), 
  .add_op_b(conv_tens_trans_spec.tens_trans_addrs.tens_src_b_addr),
  .add_op_val(conv_addr_gen_i_off_val),
  .add_res(conv_addr_gen_x_offset),
  .add_res_val(conv_addr_gen_x_offset_val)
);

del_chain  
#(
    .IN_WORD_WDT(C_MMEM_ADDR_WDT),
    .DEL_CYC_LEN(C_CONV_ADDR_GEN_X_OFFSET_DEL_CYC_LEN)
)
conv_addr_gen_x_offset_del_chain //delay (offset + x) to match latency of (TENS_IN[1] * (y + TENS_IN[0] * z))
(
    .clk(clk),
    .rst_n(rst_n),
    .clk_en(clk_en),
    .in_word(conv_addr_gen_x_offset),
    .in_word_val(conv_addr_gen_x_offset_val),
    .in_word_del(conv_addr_gen_x_offset_del),
    .in_word_val_del(conv_addr_gen_x_offset_val_del)
);

mult_cell
#(
    .MULT_ARITH_CFG(C_ADDR_MULT_ARITH_CFG),
    .MULT_IN_CYC_LEN(C_MULT_ADDR_IN_CYC_LEN),
    .MULT_OUT_CYC_LEN(C_MULT_ADDR_OUT_CYC_LEN)
)
mult_conv_addr_gen_z_height //compute: TENS_IN[0] * z
( 
  .clk(clk),
  .rst_n(rst_n),
  .clk_en(clk_en),
  .mult_op_a(conv_addr_gen_z_i_off), 
  .mult_op_b(conv_tens_trans_spec.tens_trans_conv_dims.tens_src_b_dims.tens_0_dim),
  .mult_op_val(conv_addr_gen_i_off_val),
  .mult_res(conv_addr_gen_z_height),
  .mult_res_val(conv_addr_gen_z_height_val)
);

del_chain  
#(
    .IN_WORD_WDT(C_TENS_INDEX_WDT),
    .DEL_CYC_LEN(C_MULT_ADDR_CYC_LEN)
)
conv_addr_gen_y_i_del_chain //delay y to match latency of TENS_IN[0] * z
(
    .clk(clk),
    .rst_n(rst_n),
    .clk_en(clk_en),
    .in_word(conv_addr_gen_y_i_off),
    .in_word_val(conv_addr_gen_i_off_val),
    .in_word_del(conv_addr_gen_y_i_off_del),
    .in_word_val_del(conv_addr_gen_i_off_val_del)
);

add_cell 
#(
    .ADD_ARITH_CFG(C_ADDR_ADD_ARITH_CFG),
    .ADD_IN_CYC_LEN(C_ADD_ADDR_IN_CYC_LEN),
    .ADD_OUT_CYC_LEN(C_ADD_ADDR_OUT_CYC_LEN)
)
add_conv_addr_gen_yz //compute: (y + TENS_IN[0] * z)
( 
  .clk(clk),
  .rst_n(rst_n),
  .clk_en(clk_en),
  .add_op_a(conv_addr_gen_y_i_off_del), 
  .add_op_b(conv_addr_gen_z_height),
  .add_op_val(conv_addr_gen_i_off_val_del & conv_addr_gen_z_height_val),
  .add_res(conv_addr_gen_yz),
  .add_res_val(conv_addr_gen_yz_val)
);

mult_cell
#(
    .MULT_ARITH_CFG(C_ADDR_MULT_ARITH_CFG),
    .MULT_IN_CYC_LEN(C_MULT_ADDR_IN_CYC_LEN),
    .MULT_OUT_CYC_LEN(C_MULT_ADDR_OUT_CYC_LEN)
)
mult_conv_addr_gen_yz_width //compute: TENS_IN[1] * (y + TENS_IN[0] * z)
( 
  .clk(clk),
  .rst_n(rst_n),
  .clk_en(clk_en),
  .mult_op_a(conv_addr_gen_yz), 
  .mult_op_b(conv_tens_trans_spec.tens_trans_conv_dims.tens_src_b_dims.tens_1_dim),
  .mult_op_val(conv_addr_gen_yz_val),
  .mult_res(conv_addr_gen_yz_width),
  .mult_res_val(conv_addr_gen_yz_width_val)
);

add_cell 
#(
    .ADD_ARITH_CFG(C_ADDR_ADD_ARITH_CFG),
    .ADD_IN_CYC_LEN(C_ADD_ADDR_IN_CYC_LEN),
    .ADD_OUT_CYC_LEN(C_ADD_ADDR_OUT_CYC_LEN)
)
add_conv_addr_gen_fin //compute: (x + offset) + TENS_IN[1] * (y + TENS_IN[0] * z)
( 
  .clk(clk),
  .rst_n(rst_n),
  .clk_en(clk_en),
  .add_op_a(conv_addr_gen_x_offset_del), 
  .add_op_b(conv_addr_gen_yz_width),
  .add_op_val(conv_addr_gen_x_offset_val_del & conv_addr_gen_yz_width_val),
  .add_res(conv_addr_gen_fin),
  .add_res_val(conv_addr_gen_fin_val)
);

//construct the output
always_comb begin : fin_res_mux_proc
    conv_addr_gen_rd_mmem_q = conv_addr_gen_rd_mmem_i;

    if(conv_addr_padd_val_del & conv_addr_gen_fin_val & conv_addr_gen_rd_mmem_val) begin
        conv_addr_gen_rd_mmem_q.cmd_rd_data_vect_zero_padd    = conv_addr_padd_del & conv_addr_padd_val_del & conv_tens_trans_spec.tens_trans_cfg.tens_trans_type == TRANS_CONV;
        conv_addr_gen_rd_mmem_q.cmd_rd_data_vect_neg_inf_padd = conv_addr_padd_del & conv_addr_padd_val_del & conv_tens_trans_spec.tens_trans_cfg.tens_trans_type == TRANS_MAXPOOL;
        conv_addr_gen_rd_mmem_q.cmd_rd_addr                   = conv_addr_gen_fin;
    end else begin
        conv_addr_gen_rd_mmem_q.cmd_rd_data_vect_zero_padd = '0;
        conv_addr_gen_rd_mmem_q.cmd_rd_addr                = '0;
    end
end

// synthesis translate_off

//assertions
always @(posedge clk) assert ((conv_addr_gen_z_i_val & conv_addr_gen_x_i_val & conv_addr_gen_y_i_val) | (!conv_addr_gen_z_i_val & !conv_addr_gen_x_i_val & !conv_addr_gen_y_i_val) | !rst_n) 
    else $error("Valid flags of latency matched signals shall be all asserted or all deasserted!");

always @(posedge clk) assert ((conv_addr_gen_z_i_off_val & conv_addr_gen_x_i_off_val & conv_addr_gen_y_i_off_val) | (!conv_addr_gen_z_i_off_val & !conv_addr_gen_x_i_off_val & !conv_addr_gen_y_i_off_val) | !rst_n) 
    else $error("Valid flags of latency matched signals shall be all asserted or all deasserted!");

always @(posedge clk) assert ((conv_addr_gen_x_offset_val_del & conv_addr_gen_yz_width_val) | (!conv_addr_gen_x_offset_val_del & !conv_addr_gen_yz_width_val) | !rst_n) 
    else $error("Valid flags of latency matched signals shall be all asserted or all deasserted!");

always @(posedge clk) assert ((conv_addr_padd_val_del & conv_addr_gen_fin_val) | (!conv_addr_padd_val_del & !conv_addr_gen_fin_val) | !rst_n) 
    else $error("Valid flags of latency matched signals shall be all asserted or all deasserted!");
// synthesis translate_on

endmodule